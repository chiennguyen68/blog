<div class="s-layout">
  <!-- Sidebar -->
  <div class="s-layout__sidebar">
    <nav class="s-sidebar__nav" style="z-index: 9999;">
      <ul>
        <li>
          <img class="avt" src="../assets/image/avt.jpg" />

          <h4 class="name mt-2">N.D.Chien</h4>
        </li>
        <hr class="dash" />
        <li>
          <a class="s-sidebar__nav-link link" href="#home">
            <i class="fa fa-home"></i><em>Home</em>
          </a>
        </li>
        <li>
          <a class="s-sidebar__nav-link link" href="#profile">
            <i class="fa fa-user"></i><em>My Profile</em>
          </a>
        </li>
        <li>
          <a class="s-sidebar__nav-link link" href="#resume">
            <i class="fas fa-file-alt"></i><em>Resume</em>
          </a>
        </li>
        <li>
          <a class="s-sidebar__nav-link link" href="#blog">
            <i class="fa fa-blog"></i><em>Blogs</em>
          </a>
        </li>
        <li class="copyright">
          © Copyright <strong><span>Chein</span></strong><br />
          <span id="copyright-years">2022</span>
        </li>
      </ul>
    </nav>
  </div>

  <!-- Content -->
  <main class="s-layout__content">
    <div class="container-fluid p-0">
      <div class="section section-home" id="home">
        <!-- <div class="textanime">
          <p>Hello world! I'm Front-end Developer...</p>
        </div> -->
        <div style="display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;">
          <p class="swift-up-text">Hello world! I'm Front-end Developer...</p>
        </div>
      </div>
      <div class="section section-profile" id="profile">
        <div class="p-5">
          <h2 class="title">About</h2>
          <p>
            Xin chào, tôi là Chiến! Đây là nơi tôi ghi lại những kiến thức hay
            đôi khi là những chia sẻ trong quá trình làm việc, học tập những năm
            ở vị trí lập trình viên (Software engineer).
          </p>
          <div class="row">
            <div class="col-sm-4">
              <img class="avt-2" src="../assets/image/avt.jpg" />
            </div>
            <div class="col-sm-8">
              <h3>Front-end Developer</h3>
              <hr />
              <ul class="about-ul">
                <li class="about-li mt-4">
                  <strong>Birthday:</strong> 06, 08, 1999
                </li>
                <li class="about-li mt-4">
                  <strong>City:</strong>HaNoi, VietNam
                </li>
                <li class="about-li mt-4">
                  <strong>Email:</strong>chien.nguyen9c9@gmail.com
                </li>
              </ul>
            </div>
          </div>
          <div class="row">
            <h2 class="title mt-5">Experience</h2>
            <div style="display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between;">
              <div class="company">
                <img class="logo me-2" src="../assets/image/logo.png" />
                <div class="row">
                  <p>Front-end Developer</p>
                  <p class="font-weight-bold">Monkey</p>
                  <p class="date">01/08/2021 - 30/08/2022</p>
                </div>
              </div>
              <div class="company">
                <img class="logo me-2" src="../assets/image/logo-vccorp.png" />
                <div class="row">
                  <p>Front-end Developer</p>
                  <p class="font-weight-bold">Vccorp</p>
                  <p class="date">01/09/2022 - 20/04/2024</p>
                </div>
              </div>
            </div>

          </div>
          <div class="row mt-4">
            <h2 class="title">Skills</h2>
            <p>Tôi đã có hơn 2 năm kinh nghiệm trong vị trí Web Developer</p>
            <div class="row">
              <div class="col-sm-3 skill-box p-2 me-4">
                <i class="fas fa-database text-info"></i>
                <p class="font-weight-bold">Back-end</p>
                <p>Php, MySQL, Lumen, Laravel.</p>
              </div>

              <div class="col-sm-3 skill-box p-2 me-4">
                <i class="fa-brands fa-angular text-danger"></i>
                <p class="font-weight-bold">Angular</p>
                <p>Angular,Component, Rxjs, Observable, Forms, NgPrime, Ngx-Bootstrap.</p>
              </div>
              <div class="col-sm-3 skill-box p-2">
                <i class="fa-brands fa-react text-primary"></i>
                <p class="font-weight-bold">React</p>
                <p>React Function and Class Component, Mobx , Flux Architecture, React Microservices</p>
              </div>
              <div class="col-sm-3 skill-box p-2 mt-2">
                <img width="16" height="16" src="https://img.icons8.com/color/16/nextjs.png" alt="nextjs" />
                <p class="font-weight-bold">NextJS</p>
                <p>App Router, Navigation, Client and Server Component, Data Fetching, API Routes, Turborepo with
                  Nextjs,
                  NextAuth
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="clearfix"></div>
      <div class="section" id="resume">
        <div class="p-5">
          <h2 class="title">Resume</h2>
          <div class="row">
            <div class="col-sm-6">
              <h3 class="font-weight-bold mt-2">Professional Experience</h3>
              <div class="resume-item">
                <h4 class="font-weight-bold">
                  VTI ACADEMY - Xây dựng Landing page quảng cáo khóa học
                </h4>
                <p>Thực tập sinh</p>
                <p class="date">1/11/2020 - 1/4/2021</p>
                <ul>
                  <li>
                    Nghiên cứu và ứng dụng công nghệ đã học áp dụng xây dựng
                    landing page quảng cáo.
                  </li>
                  <li>Trực tiếp xây dựng source code và upload hosting.</li>
                  <li class="site">http://java.vtieducation.vn</li>
                  <li class="site">http://asp.net.vtieducation.vn</li>
                  <li class="site">http://php.vtieducation.vn</li>
                  <li class="site">http://android.vtieducation.vn</li>
                </ul>
              </div>

              <div class="resume-item">
                <h4 class="font-weight-bold">Monkey - Dự án Hoc10.vn</h4>
                <p>Lập trình viên</p>
                <p class="date">01/08/2021 - 30/8/2022</p>
                <ul>
                  <li>
                    Trực tiếp xây dựng và phát triển tính năng cho dự án Hoc10
                  </li>
                  <li>
                    Cùng team đưa ra những giải pháp giải quyết các vấn đề người
                    dùng theo mô hình Agile Scrum
                  </li>
                  <li class="site">Phát triển version 2 của website Hoc10</li>

                  <li class="site">
                    Phát triển tính năng luyện tập, luyện thi cho học sinh
                  </li>

                  <li class="site">
                    Phát triển tính năng tập huấn, upload và chia sẻ slide bài
                    giảng cho giáo viên
                  </li>
                  <li class="site">
                    Phát triển tính năng báo cáo chi tiết sách, game, luyện tập,
                    luyện thi, ngân hàng câu hỏi
                  </li>
                  <li class="site">
                    Phát triển tính năng báo lỗi trên sách, bài luyện tập, bài
                    luyện thi, tập huấn
                  </li>
                  <li class="site">
                    Phát triển tính năng tự động tạo bộ đề thi từ ngân hàng câu
                    hỏi
                  </li>
                  <li>Maintain fix bug hệ thống</li>
                  <li>
                    Giải khuyến khích cuộc thi sáng tạo công nghệ We Share do
                    Monkey tổ chức
                  </li>

                  <li class="site">
                    Lên ý tưởng cùng team, tìm hiểu công nghệ sử dụng, trực tiếp
                    xây dựng và phát triển game RPG-2D học tiếng anh bằng đồ vật
                  </li>
                </ul>
              </div>
              <div class="resume-item">
                <h4 class="font-weight-bold">Vccorp - Vận hành và phát triển sản phẩm trong dự án IMS</h4>
                <p>Lập trình viên</p>
                <p class="date">01/09/2022 - 20/04/2024</p>
                <ul>
                  <li>
                    Trực tiếp xây dựng và phát triển tính năng cho dự án IMS theo mô hình microservice
                  </li>
                  <li>
                    Xây dựng tool chuyển đổi ngôn ngữ markdown thành html và ngược lại
                  </li>
                  <li>Xây dựng tool tạo và cắt ghép chỉnh sửa video (giống clipchamp.com)</li>

                  <li>
                    Bảo trì và phát triển tool quản lí thư viện template
                  </li>

                  <li>
                    Phát triển gói chức năng tính phí cho báo người lao động
                  </li>
                </ul>
              </div>
            </div>
            <div class="col-sm-6">
              <h3 class="font-weight-bold mt-2">Sumary</h3>
              <div class="resume-item">
                <h4 class="font-weight-bold">Nguyễn Đức Chiến</h4>
                <p>
                  Tôi có 2 năm kinh nghiệm trong vị trí Web Developer. Ngoài
                  công việc chuyên môn tôi có niềm đam mê với Game, Anime.
                </p>
                <ul>
                  <li>Ha Noi, Viet Nam</li>
                  <li>chien.nguyen9c9@gmail.com</li>
                </ul>
              </div>

              <h3 class="font-weight-bold mt-2">Education</h3>
              <div class="resume-item">
                <h4 class="font-weight-bold">
                  Đại học sư phạm kỹ thuật hưng yên
                </h4>
                <p class="date">2017-2021</p>
                <ul>
                  <li>Chuyên ngành: Công nghệ web</li>
                  <li>Tốt nghiệp loại khá 7.2/10</li>
                </ul>
              </div>
            </div>

          </div>
        </div>
      </div>
      <div class="section" id="blog">
        <div class="p-5">
          <h2 class="title">Blogs</h2>
          <div class="carousel mt-4" data-flickity='{ "imagesLoaded": true, "percentPosition": false }'>
            <div>
              <img src="https://www.profellow.com/wp-content/uploads/2017/08/Writers-Block.jpg" alt="orange tree" />
              <div class="centered">
                <p>Dependency Injection trong Ứng Dụng Angular</p>
                <button type="button" class="btn btn-info" data-bs-toggle="modal" data-bs-target="#modal1">
                  Xem thêm ...
                </button>
              </div>
            </div>

            <div>
              <img src="https://www.profellow.com/wp-content/uploads/2017/08/Writers-Block.jpg" alt="orange tree" />
              <div class="centered">
                <p>
                  Sự khác nhau giữa Observable và Promise khi áp dụng trong
                  Angular
                </p>
                <button type="button" class="btn btn-info" data-bs-toggle="modal" data-bs-target="#modal2">
                  Xem thêm ...
                </button>
              </div>
            </div>
            <div>
              <img src="https://www.profellow.com/wp-content/uploads/2017/08/Writers-Block.jpg" alt="orange tree" />
              <div class="centered">
                <p>Tìm hiểu Pipe trong Angular</p>
                <button type="button" class="btn btn-info" data-bs-toggle="modal" data-bs-target="#modal3">
                  Xem thêm ...
                </button>
              </div>
            </div>
            <div>
              <img src="https://www.profellow.com/wp-content/uploads/2017/08/Writers-Block.jpg" alt="orange tree" />
              <div class="centered">
                <p>Tìm hiểu về Phaser</p>
                <button type="button" class="btn btn-info" data-bs-toggle="modal" data-bs-target="#modal4">
                  Xem thêm ...
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

<!-- Button trigger modal -->

<!-- Modal -->
<div class="modal fade" id="modal1" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="exampleModalLabel">
          Dependency Injection trong Ứng Dụng Angular
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="carouselExampleControls" class="carousel slide" data-bs-ride="carousel">
          <div class="carousel-inner">
            <div class="carousel-item active p-3" data-bs-interval="50000">
              <h3>Introduction to Dependency Injection in Angular</h3>
              <hr />
              <h4>Dependency Injection</h4>
              <hr />
              <p>
                Dependency Injection (DI) là một pattern rất quan trọng trong
                lập trình, có thể bạn đã nghe qua những Spring Framework của
                Java hay ASP.NET có support DI, vậy với Frontend application thì
                có thật sự cần thiết? Hiện nay có rất nhiều Frontend Framework
                có support DI, Angular sử dụng rất nhiều và nó có riêng một DI
                framework được thiết kế để đáp ứng được yêu cầu về mặt như kiến
                trúc hệ thống của Angular.
              </p>
              <h4>DI là gì?</h4>
              <hr />
              <p>
                Giả sử chúng ta đang làm ứng dụng giỏ hàng của một trang thương
                mại điện tử, thông thường chúng ta có thể tách những phần xử lý
                business ra thành một class để giảm responsibility của
                component, cũng như tăng tính reuseable của phần business logic
                đó. Lúc này chúng ta có thể có các thành phần như sau:
              </p>
              <img src="../assets/image/text-code.PNG" class="w-100" />
              <p>
                Các bạn có thể thấy rằng, class ProductComponent của chúng ta bị
                phụ thuộc vào (depend on) class CartService. Khi
                ProductComponent cần call các method của CartService chúng ta
                cần khởi tạo hoặc yêu cầu để lấy về một instance của service đó.
              </p>
              <h4>Khởi tạo bên trong ProductComponent</h4>
              <p>
                Để khởi tạo instance của một class bên trong một class khác,
                chúng ta có thể chỉ cần <span class="text-info">new</span> là
                được.
              </p>
              <img src="../assets/image/text-code-2.PNG" class="w-100" />
              <p>
                Nếu trong trường hợp như trên, rõ ràng chúng ta bị ràng buộc
                chặt chẽ giữa hai class (Tight Coupling), nếu bạn muốn thay đổi
                implementation khác của
                <span class="text-info">CartService</span> thì bắt buộc phải sửa
                code của <span class="text-info">ProductComponent</span> , và sẽ
                kéo theo phải test lại cả hai class.
              </p>
              <h4>Injection (Request để lấy về instance)</h4>
              <p>
                Nếu bằng một cách nào đó, chúng ta gửi một request rồi từ một
                container nào đó sẽ cung cấp instance cho chúng ta thì sao.
              </p>
              <img src="../assets/image/text-code-3.PNG" class="w-100" />
              <p>
                Và chúng ta sẽ có một container có thể biết cách khởi tạo và
                provide cho các request của các class như sau:
              </p>
              <img src="../assets/image/text-code-4.PNG" class="w-100" />
              <p>
                Lúc này bạn có thể thấy class
                <span class="text-info">ProductComponent</span> không hề biết gì
                về các khởi tạo CartService như thế nào. Nó gửi request cho
                Inversion of Control (đảo ngược sự điều khiển hay đảo ngược sự
                phụ thuộc, viết tắt là IoC) container, từ đó nó có thể lấy được
                instance mà nó mong muốn. Trong trường hợp bạn muốn đổi
                implementation cũng rất dễ dàng và hoàn toàn không cần viết lại
                class <span class="text-info">ProductComponent</span>. Các bạn
                có thể đoán được mẫu thiết kế trên chính là Dependency
                Injection, chi tiết hơn đó là constructor injection.
              </p>
              <h4>DI trong Angular</h4>
              <hr />
              <p>
                Trong Angular, DI bao gồm ba thành phần sau đây: Injector: là
                một object có chứa các API để chúng ta có thể lấy về các
                instances đã tạo hoặc tạo các instances của các phụ thuộc.
                Provider: giống như một công thức để Injector có thể biết làm
                thế nào để tạo một instance của một phụ thuộc. Dependency: là
                một object (có thể là function, một value thông thường) của một
                kiểu dữ liệu cần phải khởi tạo. Bạn có thể cung cấp injectors
                với providers ở nhiều levels khác nhau trong app, bằng một trong
                ba cách sau: Trong @Injectable() decorator cho service đó. Trong
                @NgModule() decorator (providers array) đối với NgModule. Trong
                @Component() decorator (providers array) đối với component hoặc
                directive (Chúng ta sẽ tìm hiểu chi tiết về Directive sau).
              </p>
              <p>Ví dụ về cách provide CartService:</p>
              <img src="../assets/image/text-code-5.PNG" class="w-100" />
              <img src="../assets/image/text-code-6.PNG" class="w-100" />
              <p>
                Với @Injectable decorator, chúng ta đã thêm metadata để Angular
                biết được cách để tạo instance của CartService khi có một class
                nào đó request như
                <span class="text-info">ProductComponent</span>. Và thông tin
                providedIn: 'root' sẽ chỉ cách cho Angular biết rằng chúng ta
                mong muốn service này sẽ có một instance (singleton) cho suốt
                toàn bộ app.
              </p>
              <h4>Override Provider</h4>
              <hr />
              <p>
                Giờ đây nếu hệ thống yêu cầu chúng ta thay vì lưu trữ tính toán
                thông tin giỏ hàng ở client, thì sẽ call đến một external
                datasource (API chẳng hạn) để thao tác như Thêm vào giỏ hàng,
                Tính tổng tiền. Lúc này về mặt coding, chúng ta sẽ tuân thủ theo
                đúng những gì class CartService đang có (public APIs của
                CartService), chỉ khác về mặt implementation như sau:
              </p>
              <img src="../assets/image/text-code-7.PNG" class="w-100" />
              <p>
                Bạn chỉ cần có thế và có thể tiến hành override, mà không cần
                sửa đổi lại code của
                <span class="text-info">ProductComponent</span> như sau:
              </p>
              <img src="../assets/image/text-code-8.PNG" class="w-100" />
              <p>Hoặc có thể override vào @Injectable của service</p>
              <img src="../assets/image/text-code-9.PNG" class="w-100" />
              <h4>Summary</h4>
              <p>
                Như vậy, chúng ta đã làm quen về khái niệm cũng như cách sử dụng
                cơ bản của Dependency Injection trong Angular.
              </p>
            </div>
            <div class="carousel-item p-3" data-bs-interval="50000">
              <h3>Dependency Injection trong Ứng Dụng Angular</h3>
              <hr />
              <p>
                chúng ta đã tìm hiểu và thấy rằng Dependency Injection được sử
                dụng trong ứng dụng Angular để tạo ra các Service, và các
                Service này được inject vào các class (ví dụ: component,
                directive, service) khác thông qua constructor injection. Vậy
                ngoài để tạo ra Service thì nó còn có thể sử dụng ở những đâu
                nữa.
              </p>
              <h3>Inject parent component to child component</h3>
              <p>Angular application là một component tree có dạng như sau.</p>
              <img src="../assets/image/components-tree.jpg" class="w-100" />
              <p>
                Do Angular support DI đến tận level của từng Component, nên
                chúng ta hoàn toàn có thể inject parent component vào child
                component như ví dụ sau. Giả sử chúng ta đang xây dựng Tabs
                Component để thao tác với các tab. Chúng ta sẽ có hai component
                bao gồm TabGroupComponent để quản lý các tab panel và
                TabPanelComponent tương ứng với mỗi panel.
              </p>
              <img src="../assets/image/text-code-10.PNG" class="w-100" />
              <p>
                Lúc này mỗi khi có một tab panel được thêm vào hay xóa đi thì
                tab group phải biết được để có thể xử lý tương ứng như: hiển thị
                các tab title, handle event khi select tab nào đó từ tab title.
                Và trong mỗi component của Angular chúng ta sẽ được cung cấp sẵn
                hai lifecycle method quan trọng để biết khi nào một component
                được tạo ra và sắp bị destroy đó là
                <span class="text-info">OnInit</span><span class="text-info">OnDestroy</span> . Đây chính là những
                thời điểm thích hợp để
                <span class="text-info">TabPanelComponent</span> có thể tương
                tác lại với <span class="text-info">TabGroupComponent</span> .
                Đến thời điểm hiện tại, bạn hoàn toàn có thể sử dụng
                <span class="text-info">EventEmitter</span> để notify cho parent
                component biết được các thời điểm tương ứng. Nhưng cũng có một
                cách khác, đó chính là inject parent component vào child
                component và thực hiện các hành động tương ứng.
              </p>
              <p>
                Giả sử bạn cài đặt
                <span class="font-weight-bold">tab-group.component.ts </span>
                như sau:
              </p>
              <img src="../assets/image/text-code-11.PNG" class="w-100" />
              <p>
                Và đây là phần UI cho
                <span class="font-weight-bold"> tab-group.component.html:</span>
              </p>
              <img src="../assets/image/text-code-12.PNG" class="w-100" />
              <p>
                Việc của chúng ta bây giờ chỉ là inject và call các method để
                register và remove:
              </p>
              <img src="../assets/image/text-code-13.PNG" class="w-100" />
              <h4>Provide một tab group khác có cùng APIs</h4>
              <hr />
              <p>
                Như bạn có thể thấy, tab group của chúng ta ở trên có UI cực kỳ
                đơn giản, hoặc trong trường hợp bạn muốn có UI riêng, đúng như
                design system (bootstrap, ant design, etc) đang dùng trong
                application thì sao? Chả lẽ chúng ta không reuse được gì ở trên.
                Đây là nơi tỏa sáng của DI. Bạn chỉ cần đơn giản là provide một
                provider để override là được.
              </p>
              <p>
                <span class="font-weight-bold">bs-tab-group.component.ts</span>
              </p>
              <img src="../assets/image/text-code-14.PNG" class="w-100" />
              <p>
                <span class="font-weight-bold">bs-tab-group.component.html</span>
              </p>
              <img src="../assets/image/text-code-15.PNG" class="w-100" />
              <p>Template khi sử dụng:</p>
              <img src="../assets/image/text-code-16.PNG" class="w-100" />
              <p>Hoàn toàn hợp lệ, không có lỗi gì xảy ra cả.</p>
              <p>
                Kỹ thuật này được sử dụng rất nhiều trong chính bản thân của
                Angular Framework như đối với phần Form ở đây: ngForm,
                ngModelGroup, etc.
              </p>
              <h4>Forward Reference</h4>
              <hr />
              <p>
                Trong những phần code của Form ở trên bạn thấy người ta sử dụng
                thêm <span class="text-info">forwardRef</span> vậy khi nào cần
                sử dụng nó. Như các bạn cũng biết, một class ở trong
                ES2015/TypeScript chỉ có thể refer đến nó khi nó đã được khai
                báo. Nếu chúng ta refer đến nó trước khi được khai báo thì sẽ
                trả về error (hoặc undefined khi code transpile sang ES5 với
                <span class="text-info">var</span>
                keyword). Bây giờ giả sử bạn tách phần provider ở decorator ra
                một variable đặt ở trước khi khai báo class.
              </p>
              <img src="../assets/image/text-code-17.PNG" class="w-100" />
              <p>Bạn sẽ nhận được một Error như sau:</p>
              <img src="../assets/image/text-code-26.PNG" class="w-100" />
              <p>
                Do đó chúng ta cần dùng đến closure, đó là tạo một function nó
                sẽ được call sau khi chúng ta tạo xong class, và nó sẽ có thể
                refer đến class đó ở thời điểm được gọi.
              </p>
              <img src="../assets/image/text-code-18.PNG" class="w-100" />
              <p>
                Bạn có thể thắc mắc là tại sao sử dụng trực tiếp trong decorator
                thì lại không lỗi? Câu trả lời là vì bản thân Class Decorator sẽ
                được call sau khi mà bạn đã tạo xong class.
              </p>
              <p>Bạn có thể tưởng tượng nó sẽ hoạt động giống như sau:</p>
              <img src="../assets/image/text-code-19.PNG" class="w-100" />
              <p>Sẽ tương đương với call một function như sau.</p>
              <img src="../assets/image/text-code-20.PNG" class="w-100" />
              <h4>Provider syntax</h4>
              <p>
                Như chúng ta đã tìm hiểu qua thì chúng ta có các cách provide
                một provider với các dạng như sau:
              </p>
              <p><span class="text-info">useClass:</span></p>
              <img src="../assets/image/text-code-21.PNG" class="w-100" />
              <p>Tương đương với cú pháp:</p>
              <img src="../assets/image/text-code-22.PNG" class="w-100" />
              <p><span class="text-info">useExisting:</span></p>
              <img src="../assets/image/text-code-23.PNG" class="w-100" />
              <p><span class="text-info">useFactory:</span></p>

              <img src="../assets/image/text-code-24.PNG" class="w-100" />
              <p><span class="text-info">useValue:</span></p>

              <img src="../assets/image/text-code-25.PNG" class="w-100" />
              <h4>Summary</h4>
              <p>
                Như vậy, bạn sẽ cần tìm hiểu một số kỹ thuật sử dụng DI trong
                Angular, như thế sẽ giúp bạn hiểu sâu hơn về DI trong Angular và
                có thể tạo những phần code dễ reuse, flexible hơn.
              </p>
            </div>
          </div>
          <button class="carousel-control-prev mw-0" type="button" data-bs-target="#carouselExampleControls"
            data-bs-slide="prev" style="width: 2%">
            <span class="carousel-control-prev-icon bg-dark" aria-hidden="true"></span>
            <span class="visually-hidden">Previous</span>
          </button>
          <button class="carousel-control-next mw-0" type="button" data-bs-target="#carouselExampleControls"
            data-bs-slide="next" style="width: 2%">
            <span class="carousel-control-next-icon bg-dark" aria-hidden="true"></span>
            <span class="visually-hidden">Next</span>
          </button>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
          Close
        </button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="modal2" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="exampleModalLabel">
          Sự khác nhau giữa Observable và Promise khi áp dụng trong Angular
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="carouselExampleControls" class="carousel slide" data-bs-ride="carousel">
          <div class="carousel-inner">
            <div class="carousel-item active p-3" data-bs-interval="50000">
              <p>
                Angular là một front-end framework rất nổi tiếng được phát triển
                bởi Google. Giống như các framework khác, nó sử dụng một mô hình
                dựa trên một tập hợp các component để xây dựng nên một ứng dụng.
              </p>
              <p>
                Trong bài viết lần này, chúng ta hay cùng so sánh sự khác nhau
                giữa Observable và Promise khi chúng ta làm việc với bất đồng bộ
                trong Angular.
              </p>
              <h4>Tổng quan</h4>
              <p>Có rất nhiều điểm khác nhau giữa Observable và Promise.</p>
              <p>
                Mặc dù Observable được khởi tạo, nhưng điều đó không có nghĩa là
                nó thực thi ngay lập tức. Nó sẽ không bao giờ được thực thi nếu
                như chưa được đăng ký. Còn Promise thì lại khác, nó được thực
                thi ngay khi nó được khởi tạo. Chính điều này khiến Observable
                có lợi thế hơn khi làm việc với bất đồng bộ.
              </p>
              <p>
                Observable có thể chứa được nhiều giá trị trong nó, còn Promise
                thì không. Chúng ta hãy tưởng tượng Observable như một array,
                còn Promise giống như một single value. Điều đó khiến Observable
                linh động hơn trong việc lưu trữ dữ liệu so với Promise. Bên
                cạnh đó Observable cũng chính là một dòng chảy (stream), và dòng
                chảy này được thay đổi theo thời gian. Chúng ta có thể truyền
                bất cứ giá trị nào vào dòng chảy đó và ngay lập tức Observable
                sẽ emit cho chúng ta giá trị mới.
              </p>
              <h4>Tiền xử lý dữ liệu</h4>
              <p>
                Không giống như Promise, Observable có thể thực thi quá trình
                tiền xử lý dữ liệu trước khi chúng ta đăng ký. Ví dụ:
              </p>
              <img src="../assets/image/text-code-27.PNG" class="w-100" />
              <p>
                Còn đối với Promise thì chúng ta chỉ có thể xử lý dữ liệu khi
                Promise trả về dữ liệu
              </p>
              <img src="../assets/image/text-code-28.PNG" class="w-100" />
              <h4>Khả năng huỷ</h4>
              <p>
                Sau khi chúng ta đã đăng ký một Observable, chúng ta vẫn có thể
                huỷ nó đi được, nếu như không muốn nó chạy mãi. Còn Promise thì
                lại không hỗ trợ việc này.
              </p>
              <img src="../assets/image/text-code-29.PNG" class="w-100" />
              <h4>Hướng sự kiện</h4>
              <p>
                Một điểm nữa khiến Observable vượt trội hơn so với Promise là nó
                có thể làm được các công việc liên quan đến thao tác hướng sự
                kiện. Ví dụ như khi click vào một button:
              </p>
              <img src="../assets/image/text-code-30.PNG" class="w-100" />
              <p>
                Để làm được việc đó, chúng ta cần sử dụng fromEvent của thư viện
                RxJS. fromEvent chính là một Observable, chúng ta tiến hành
                subscribe. Và khi chúng ta click vào button, Observable lúc này
                sẽ ngay lập tức emit giá trị về chúng ta. Ngoài ra, chúng ta
                cũng có thể huỷ sự kiện này nếu như không muốn thực thi nữa
              </p>
              <img src="../assets/image/text-code-31.PNG" class="w-100" />
              <p>
                Ngoài việc sử dụng Observable ra, thì chúng ta có thể làm theo
                cách thông thường là dùng addEventListener để lắng nghe sự kiện.
              </p>
              <img src="../assets/image/text-code-32.PNG" class="w-100" />
              <p>Và removeEventListener để huỷ việc lắng nghe sự kiện</p>
              <img src="../assets/image/text-code-33.PNG" class="w-100" />
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
          Close
        </button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="modal3" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="exampleModalLabel">
          Tìm hiểu Pipe trong Angular
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="modal-body">
          <div id="carouselExampleControls" class="carousel slide" data-bs-ride="carousel">
            <div class="carousel-inner">
              <div class="carousel-item active p-3" data-bs-interval="50000">
                <p>
                  Các ứng dụng thông thường đều bao gồm các tác vụ khá đơn giản:
                </p>
                <p>
                  1. Lấy dữ liệu từ server. Đơn giản là gọi API call lên server,
                  phức tạp thì listen tới một websocket để nhận được dữ liệu
                  theo thời gian thực.
                </p>
                <p>
                  2. Transform the data, ví dụ như bạn nhận được giá trị là
                  2020-06-24T09:00:00.000Z dưới định dạng ISO. Nhưng trên UI
                  mình phải show ở format dễ đọc cho user Jun 24, 2020.
                </p>
                <p>3. Và hiển thị dữ liệu lên UI cho người dùng.</p>
                <p>
                  Pipes sẽ lo phần thứ 2, transform data trước khi show cho
                  người dùng.
                </p>
                <h4>Pipes là gì?</h4>
                <hr />
                <p>
                  Hiểu đơn giản, pipe là một function nhận input mà chúng ta
                  truyền vào, và output ra giá trị mình mong muốn. Ví dụ giữa
                  client và server khi trao đổi thông tin liên quan đến thời
                  gian, thường dùng ISO format "2020-06-24T09:00:00.000Z", tương
                  đương với ngày 24 tháng 6, 5h chiều (giờ Singapore). Tuy nhiên
                  khi hiển thị, mình ko thể hiển trị trực tiếp ISO string cho
                  người dùng vì chắc chắn là ko phải ai cũng là developer để
                  hiểu được đó là gì. Vậy nên chúng ta cần transform ISO string
                  ở trên dưới dạng mà người dùng có thể hiểu được, ví dụ Jun 24,
                  2020, 5:00:00 PM. Để làm được việc này bạn có khá nhiều lựa
                  chọn, nhưng thường thì có hai lựa chọn trong Angular:
                </p>
                <p>1. Viết một function, nhận date input và return output.</p>
                <p>2. Viêt một pipe, cũng nhận input và return output.</p>
                <p>
                  Điểm lợi thế của Pipe là dễ tái sử dụng. Vì thông thường sẽ có
                  khá nhiều page cần hiển thị date time, việc dùng Pipe sẽ đem
                  lại nhiều ưu điểm hơn là function.
                </p>
                <h4>Dùng pipe như thế nào?</h4>
                <p>
                  Angular có cung cấp sẵn một số pipes thường dùng trong package
                  @angular/common. Tuy nhiên số lượng pipe có sẵn đó cũng không
                  thể nào đáp ứng được hết các nhu cầu trong các ứng dụng khác
                  nhau, nên chúng ta cũng hoàn toàn có thể viết các custom pipe
                  theo nhu cầu thực tế.
                </p>
                <p>
                  Như đã nói, pipe sẽ nhận vào input và output ra một giá trị
                  mình mong muốn.
                </p>
                <p>Mình có một biến tên là now ở trong component.</p>
                <img src="../assets/image/text-code-34.PNG" class="w-100" />
                <p>
                  Và đây là cách mình hiển thị với built in pipe Date trong
                  Angular
                </p>
                <img src="../assets/image/text-code-35.PNG" class="w-100" />
                <p>
                  Chú ý phần giữa hai dấu ngoặc nhọn , ngoài việc truyền vào
                  variable bạn muốn hiển thì thì có thêm dấu xổ dọc |. Đó là
                  pipe operator, sau đó là tên của pipe bạn đã định nghĩa. Tất
                  cả pipe đều hoạt động theo cách này.
                </p>
                <h4>Pipe and parameters</h4>
                <p>
                  Pipe cho phép truyền thêm các parameters, ví dụ date ở trên
                  mình có thể truyền thêm format medium phân tách nhau bằng dấu
                  hai chấm :. Đó cũng là cú pháp để pass parameter cho pipe.
                </p>
                <img src="../assets/image/text-code-36.PNG" class="w-100" />
                <p>Bạn có thể truyền vào số lượng parameter không giới hạn.</p>
                <h4>Chaining pipe</h4>
                <p>
                  Pipes cho phép chúng ta dùng nhiều pipe để transform một
                  value, cú pháp có dạng như sau.
                </p>
                <img src="../assets/image/text-code-37.PNG" class="w-100" />
                <p>
                  Sau khi có output pipe_name_1, thì output này sẽ được xử lý
                  qua pipe_name_2 rồi tương tự đến pipe_name_n để ra output cuối
                  cùng hiển thị lên UI. Vẫn ví dụ với date ở trên, mình sẽ thêm
                  pipe uppercase để chuyển hết text thành chữ hoa. Sau khi biến
                  now được xử lý bằng date pipe sẽ có value Jun 24, 2020,
                  5:00:00 PM, sau đó uppercase sẽ transform thành JUN 24, 2020,
                  5:00:00 PM. Thứ tự thực hiện sẽ là từ trái qua phải. Sau khi
                  pipe_name_1 chạy xong có value thì pipe_name_2 sẽ nhận vào
                  output từ pipe_name_1.
                </p>
                <img src="../assets/image/text-code-38.PNG" class="w-100" />
                <h4>Các pipe có sẵn đi kèm với Angular (built-in pipe)</h4>
                <hr />
                <img src="../assets/image/text-code-41.PNG" class="w-100" />
                <h4>Viết custom pipe</h4>
                <p>
                  Ví dụ này lấy từ chính application đang chạy của mình. Use
                  case đơn giản là bọn mình cần code rất nhiều form CRUD. Vì
                  thường form dành cho add item và form dành cho edit item sẽ
                  được reuse cùng code HTML. Nếu bạn click Add item, form add sẽ
                  được hiển thị và title của form lúc đó sẽ là Add Item, tương
                  tự cho edit. Khi mở form Edit, trong router có truyền itemId
                  lên URL nên bọn mình biết được đây là form Edit. Còn form Add
                  thì sẽ không có itemId. Thông thường bọn mình có thể viết đi
                  viết lại một cái logic trong từng component.
                </p>
                <img src="../assets/image/text-code-42.PNG" class="w-100" />
                <p>
                  Cho đến một ngày một dev mắc một lỗi typo ngớ ngẩn là thay vì
                  Add, bạn ấy type thành Adđ (Vì có bật Unikey :))) Thế là mình
                  quyết định viết một pipe đơn giản là nhận vào một string, nếu
                  string này có value, show Edit, còn không thì show Add. Tránh
                  được lỗi typo như ở trên về sau. Để viết một pipe dành riêng
                  cho nhu cầu của từng dự án, cần follow hai bước sau.
                </p>
                <h4>
                  1. Trước tiên chúng ta cần tạo một class có implement
                  interface PipeTransform.
                </h4>
                <p>
                  Interface này chỉ bao gồm một method duy nhất tên là
                  transform. Đây là interface PipeTransform cần implement
                </p>
                <img src="../assets/image/text-code-43.PNG" class="w-100" />
                <p>Đây là ví dụ một class sau khi đã implement PipeTransform</p>
                <img src="../assets/image/text-code-44.PNG" class="w-100" />
                <p>
                  Đại khái là method transform ở đây rất đơn giản. Nếu
                  resourceId là truthy thì return Edit, nếu ko thì return lại
                  Add.
                </p>
                <h4>
                  Thêm Pipe decorator cho class đã implement PipeTransform
                </h4>
                <p>
                  Giống như component có decorator @Component. Pipe cũng có
                  decorator @Pipe.
                </p>
                <img src="../assets/image/text-code-45.PNG" class="w-100" />
                <p>
                  Khi thêm Pipe decorator thì có một property là required, đó
                  chính là tên của pipe. Mình đặt là appTitle. Nhớ là phải đặt
                  AppTitlePipe trong mảng declarations ở module tương ứng mà bạn
                  muốn sử dụng. Nếu không Angular sẽ báo lỗi. Xong rồi đây, giờ
                  mình có thể dùng appTitle như bình thường.
                </p>
                <img src="../assets/image/text-code-46.PNG" class="w-100" />
                <p>
                  Class name follow UpperCamelCase, tức là viết hoa các chữ cái
                  đầu của từng từ name của pipe sẽ follow theo camelCase, tức là
                  chữ cái đầu của từ đầu tiên viết thường. Các chữ cái đầu của
                  các từ tiếp theo viết hoa. Không được dùng dấu gạch ngang -
                  cho name Chi tiết có trong
                  <a class="text-info" href="https://angular.io/guide/styleguide#pipe-names">Angular Style Guide</a>
                </p>
                <h4>Custom pipe parameters</h4>
                <p>
                  Vẫn là ví dụ trên, nhưng ở một vài page có yêu cầu là khi mở
                  form Add, sẽ không hiện title là Add nữa, mà đổi lại thành
                  Set. Ví dụ Set Item. Còn form Edit thì đổi lại thành Change.
                  Mình hoàn toàn có thể truyền vào hai parameters tương ứng với
                  hai text này. Và nếu mặc định không truyền mình sẽ set lại Add
                  và Edit tương ứng. Code của mình có thể được viết lại như sau:
                </p>
                <img src="../assets/image/text-code-47.PNG" class="w-100" />
                <p>Và dùng trên UI</p>
                <img src="../assets/image/text-code-48.PNG" class="w-100" />
                <p>
                  Method transform sẽ nhận vào nhiều argument. Trong đó:
                  Argument đầu tiên chính là value của variable khi mình dùng
                  pipe. Ví dụ span userId | appTitle thì transform(resourceId:
                  string). resourceId chính là value của userId được truyền vào.
                  Khi truyền các parameter khác bằng dấu hai chấm : thì argument
                  tương ứng trong method transform sẽ là từ argument thứ 2 trở
                  đi. Ví dụ như userId | appTitle: "Set":"Change" thì "Set" sẽ
                  là value của addText: string và "Change" sẽ tương ứng với
                  editText: string
                </p>
                <h4>Detecting changes with data binding in pipes</h4>
                <hr />
                <h4>Primitive type</h4>
                <p>
                  Với pipe appTitle ở trên, vì mình truyền vào giá trị string
                  cho argument resourceId. Nên khi value của resourceId thay
                  đổi, pipe nhận biết được là có sự thay đổi và update UI tương
                  ứng. Ví dụ:
                </p>
                <img src="../assets/image/text-code-49.PNG" class="w-100" />
                <img src="../assets/image/text-code-50.PNG" class="w-100" />
                <p>
                  Vậy đối với primitive type như string, boolean, number.
                  Angular detech changes khá là straight forward. Mỗi khi value
                  thay đổi thì pipe cũng sẽ update theo. Còn đối với các
                  reference type như object hay array thì sao nhỉ?
                </p>
                <h4>Reference type</h4>
                <p>Ví dụ như có một mảng của users như sau.</p>
                <img src="../assets/image/text-code-51.PNG" class="w-100" />
                <p>
                  Mình có một pipe tên là isAdult, để filter ra những user lớn
                  hơn 18 tuổi.
                </p>
                <img src="../assets/image/text-code-52.PNG" class="w-100" />
                <p>Và mình render cả 2 list lên màn hình</p>
                <img src="../assets/image/text-code-53.PNG" class="w-100" />
                <img src="../assets/image/text-code-54.PNG" class="w-100" />
                <p>
                  Như các bạn thấy list những người trưởng thành hiện không có
                  user Tuan Anh dc render, chứng tỏ pipe đã hoạt động như ý mình
                  muốn Bây giờ mình add thêm 2 textbox để điền user và tuổi,
                  cùng với một button để add thêm user vào mảng users. Tuy nhiên
                  khi add thêm một user với tuổi lớn 18 vào mảng users. Phần
                  render list người lớn bên phải ko tự update.
                </p>
                <img src="../assets/image/text-code-55.PNG" class="w-100" />
                <img src="../assets/image/text-code-56.PNG" class="w-100" />
                <p>
                  Mình push thêm phần tử mới vào mảng khi click add. Tức là
                  mutate giá trị của mảng trực tiếp, chứ không gán một reference
                  mới cho mảng. Điều này dẫn đến một đặc điểm quan trọng của
                  Pipe.
                </p>
                <p>
                  Mặc định pipe luôn pure (tinh khiết), tức là pipe chỉ trigger
                  lại khi giá trị của input đầu vào, tức là thay đổi value với
                  primitive type và thay đổi reference đối với object. Nên khi
                  mình push trực tiếp phần tử vào mảng, reference của mảng không
                  thay đổi. Dẫn đến pipe ko được execute lại và ko update lên
                  UI. Việc check reference thay đổi nhanh hơn rất nhiều so với
                  việc phải check từng phần trong array hay từng property trong
                  object xem có thay đổi hay không. Nên khuyến cáo luôn dùng
                  pure Pipe khi có thể. Để fix, có hai cách
                </p>
                <h4>1. Update the variable reference</h4>
                <p>
                  Tức là thay vì mình push một item vô mảng users. Thì mình sẽ
                  gán mảng users bằng một mảng mới với tất cả items cũ và item
                  mới được add. Đoạn code ở trên sẽ được sửa lại thành.
                </p>
                <img src="../assets/image/text-code-57.PNG" class="w-100" />
                <p>
                  Bây giờ thì bạn thấy list người lớn cũng đã được update khi
                  mình bấm nút.
                </p>
                <img src="../assets/image/text-code-58.PNG" class="w-100" />
                <h4>2. Set impure Pipe</h4>
                <p>
                  Nếu bạn muốn trigger pipe khi có thay đổi value của một phần
                  tử trong array, hay khi một property của object bị thay đổi.
                  Bạn có thể cấu hình pipe của bạn với thuộc tính pure với giá
                  trị false trong decorator. Mặc định, pure luôn có giá trị
                  true.
                </p>
                <img src="../assets/image/text-code-59.PNG" class="w-100" />

                <h4>Summary</h4>
                <hr />
                <p>
                  hy vọng các bạn đã hiểu được Pipe và các use case phổ biến
                  trong việc dùng Pipe. Cũng như sự khác nhau giữa pure và
                  impure Pipe cùng change detection.
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
          Close
        </button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="modal4" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="exampleModalLabel">Tìm hiểu về Phaser</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="modal-body">
          <div id="carouselExampleControls" class="carousel slide" data-bs-ride="carousel">
            <div class="carousel-inner">
              <div class="carousel-item active p-3" data-bs-interval="50000">
                <h3>1.Phaser là gì?</h3>
                <p>
                  Phaser là một HTML5 game framework mã nguồn mở. Phaser sử dụng
                  Pixi.js để rendering trên WebGL và Canvas , Phaser hỗ trợ các
                  trình duyệt web trên cả desktop và mobile. Game được phát
                  triển bởi Phaser có thể dễ dàng được biên soạn thành ứng dụng
                  cho iOS, Android và desktop thông qua các công cụ của bên thứ
                  ba. Phaser là một framework cho HTML5 nên có thể viết bằng
                  JavaScript hoặc TypeScript. Hiện tại Phaser đã có Phaser 2 và
                  3, version mới nhất của phaser 2 là 2.6.2. Phaser 3 đã ra mắt
                  tuy nhiên not yet ready for production use Cùng với cộng đồng
                  mã nguồn mở, Phaser được tích cực phát triển và duy trì bởi
                  Photon Storm. Nhờ việc hỗ trợ nhanh chóng và xâu dựng một API
                  thân thiện với người phát triển, Phaser hiện là một trong
                  những most starred game frameworks trên GitHub.
                </p>
                <h4>2.Cài đặt Phaser</h4>
                <p>
                  Có 2 cách để install Phaser: Sử dụng bower (hoặc npm) và dùng
                  CDN
                </p>
                <img src="../assets/image/text-code-60.PNG" class="w-100" />
                <h4>Webpack</h4>
                <p>
                  Bắt đầu từ Phaser 2.4.5, người dùng có thể sử dụng Webpack Khi
                  đó p2 trở thành một dependency.
                </p>
                <p>Webpack Config</p>
                <img src="../assets/image/text-code-61.PNG" class="w-100" />
                <p>Main js file</p>
                <img src="../assets/image/text-code-62.PNG" class="w-100" />
                <h4>Game Breakout</h4>
                <img src="../assets/image/text-code-63.PNG" class="w-100" />
                <p>
                  Breakout là game có luật chơi đơn giản: Có 4 hàng x 15 viên
                  gạch(break) Có một thanh ngang(paddle) và một quả bóng đặt ở
                  trên(ball) Khi người chơi click thì quả bóng sẽ bay lên. Mỗi
                  khi quả bóng chạm vào một viên gạch thì viên gạch đó sẽ biến
                  mất Người chơi phải dùng thanh ngang đỡ quả bóng khi nó đang
                  rơi xuống Khi tất cả breaks biến mất thì sẽ qua bàn mới. Khi
                  người chơi mất hết mạng tức là làm rơi tất cả số bóng thì game
                  over Trong code phaser game Breakout có 3 func chính: preload:
                  load các assets cần thiết create: được chạy 1 lần, khởi tạo và
                  thiết lập cấu hình update: sẽ được chạy sau một khoảng delta
                  cố định để cập nhật thay đổi
                </p>
                <h4>Preload</h4>
                <p>
                  Ở bước này thì đơn thuần là load asset cho game: background,
                  các hình ảnh của bricks, ball, paddle
                </p>
                <img src="../assets/image/text-code-64.PNG" class="w-100" />
                <h4>Create</h4>
                <p>
                  Tạo backgound từ một image, starfield là image ta đã khai báo
                  ở preload
                </p>
                <img src="../assets/image/text-code-65.PNG" class="w-100" />
                <p>Tạo 4 hàng x 15 bricks</p>
                <img src="../assets/image/text-code-66.PNG" class="w-100" />
                <p>Tạo paddle và ball</p>
                <img src="../assets/image/text-code-67.PNG" class="w-100" />
                <p>
                  Thêm sự kiện khi ball bị rơi ra ngoài paddle tức là người chơi
                  dùng thanh ngang đỡ trượt khi quả bóng rơi xuống. Lúc nàyta
                  giảm lives xuống, kiểm tra nếu lives = 0 thì game over, không
                  thì ta reset, đặt bóng quay trở lại paddle
                  ball.reset(paddle.body.x + 16, paddle.y - 16);
                </p>
                <img src="../assets/image/text-code-68.PNG" class="w-100" />
                <p>
                  Thêm event khi ball rơi xuống tiếp xúc với paddle. Lúc này ta
                  chỉ cẩn set velocity để ball khi chạm vào paddle thì bật ngược
                  lại
                </p>
                <img src="../assets/image/text-code-69.PNG" class="w-100" />
                <h4>Update</h4>
                <img src="../assets/image/text-code-70.PNG" class="w-100" />
                <p>
                  Nếu toàn bộ các bricks đã bị vỡ thì sang level mới và đưa ball
                  về đặt trên paddle
                </p>
                <img src="../assets/image/text-code-71.PNG" class="w-100" />
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
          Close
        </button>
      </div>
    </div>
  </div>
</div>
